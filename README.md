# refactoring

## 第二章： 重构的原则

### 1. 何谓重构

重构理解：调整软件内部结构，在不改变软件行为的前提，提高代码可理解性。降低修改成本。

- 重构的关键：

1. 使用重构的一系列手法重构，保证代码的可运行，并且能随时停止重构。
2. 重构不改变软件之前的功能。
3. 重构和性能优化相似，但是重构不考虑代码的性能，只让代码更容易理解，性能优化可能会造成代码更难理解。

### 2. 两顶帽子

> 帽子的理解：生活中帽子只会戴一个（比较个性的另说）。比喻添加新功能和重构只能一次进行一个。

### 3. 为何重构

1. 重构改进软件的设计；随着代码的增加和功能增加，出现原先的设计不适合现在的需求，从而导致代码重复，混乱，臃肿，此时代码的设计就需要更改。
2. 重构使软件共容易理解；代码的理解更容易，更方便后续人员的修改。
3. 重构帮助找到 bug；重构时需要更深入的理解代码的表达的意思，从而能找出里面的 bug
4. 重构提高编程速度；大型项目业务复杂程度增加，原先的设计不能支撑现有的业务。此时添加新功能，可能会导致之前的代码出现 bug。

### 4. 何时重构

> 重构法则：事不过三，三则重构

1. 预备性重构：让添加新功能（改 bug）更容易；在新增功能时，重构之后更容易实现新功能（改 bug）此时开始重构。
2. 帮助理解的重构：使代码更易动；修改一些变量的名字，让代码更易懂。
3. 捡垃圾式重构：在开发功能时，发现可以重构的代码。但是不想从现在的任务停下，此时记录需要重构的地方。完成任务再回来重构。一点点修改。
4. 有计划的重构和见机行事的重构；计划重构就是给出具体的时间进行重构，见机行事的重构就是在项目开发过程中，发现可以重构但是不耗时的重构。
5. 长期重构；指在开发过程中团队改到，需要重构的代码，就进行重构。保证是一个长期的行为。
6. 复审代码时重构(code review);代码审核时进行重构。重构时代码的开发者和审核者都在现场。这个也是导向到结对编程：在进行的过程中，进行代码重构
7. 重构的禁忌；就是什么时候不该进行重构。一代码凌乱但是不需要修改时。二重写比重构还容易时。

### 5. 重构的挑战

1. 延缓新功能开发
   Q：重构会延缓新功能的开发的看法是普遍的的看法，如何处理？
   A:1）新功能非常小，重构很大。应该先进行功能的开发。
   2）重构能让新功能更好的开发，优先重构，再开发新功能。
   3）需要重构的代码开发中没有带来额外的问题，不去重构
   4）重构的代码没有想到优化的点，那就延迟重构

2. 代码所有权
   Q: 代码所有权对重构的影响？
   A：例如：调用者是另外一个团队，而我没有权限写入他们的代码库，甚至不知道谁调用了这些方法。代码所有权的会妨碍重构。虽然可以保留之前的函数声明，但是会让代码变的复杂。所以不建议搞细粒度的代码所有制。宽松的代码所有制，方便跨团队合作。
3. 分支
   Q：分支对重构的影响？
   A：团队开发时，都是基于主分支新建分支开发，当 A 在重构，而 B 在开发功能，如果 B 的功能依赖 A 重构的方法。B 的功能代码合并到主分支，就会引起冲突。
   1）使用持续集成（CI），至少保证每天都向主分支集成一次。
   2）将大功能拆分为小块，将无法拆小的功能呢隐藏
4. 测试
   Q：测试对重构有什么影响？
   A：测试可以保证添加的新功能、重构更安全，能更迅速的找出 bug，

5. 遗留代码
   Q: 遗留代码对重构的影响？
   A：遗留代码的重构，那么就必须添加测试，测试可以保证重构的安全，以及理顺遗留的代码。
6. 数据库
   Q：数据库的重构经常出问题，如何处理？
   A：重构时要小步修改，修改必须完整。重构后分多次发布来完成。有问题可以方便回滚。

### 6. 重构、架构和 YAGUI（你不会需要架构）

1. 重构可以改变架构固定导致的问题。
2. 重构可以设计出良好的代码库
3. 在软件加入灵活性机制
4. 使用简单设计、增量式设置或者 YAGUI

### 7. 重构与软件的开发过程

1. 重构的基础时自测试代码，避免编程的 bug。
2. 重构的过程中不应该影响其他的开发。
3. 重构过程中应该持续集成

### 8. 重构与性能

- 快速开发的高性能呢软件的三个方法

1. 时间预算法：给每个模块分配好时间和占有空间。
2. 持续关注法：开发者在任何时间做任何的事情，都要保持系统的高性能，但是通常会使程序难以维护，减缓开发速度。
3. 性能提升法：当性能问题出现时，去解决出现的问题，从而提高性能。如果重构没有让性能提升，那就撤销修改，直到性能优化成功。

### 9. 重构起源何处

认识到重构对提高生产力非常重要的是：Ward Cunningham 和 Kent Beak（沃德・坎宁安 和 肯特・比克）

### 10. 自动化重构

Q：何谓自动化重构？
A：IDE 通过 语法树来分析和重构程序代码的方式。通过识别相同代码来自动化重构。

## 第三章：代码的坏味道

1. 神秘命名：即函数，变量，类和模块的命名无法表达正确的意思。解决：使用正确可以表达意思的变量名
2. 重复代码:

- 位于同一个类：提炼成新方法进行调用
- 位于不同子类：提炼成方法到父类。
- 位于完全不相干的类：提炼成一个新类，将重复代码放入新类中。

3. 过长的函数：函数过长导致理解困难。解决：当你感觉需要用注释来说明的时候，就可以把这段代码提到独立函数。
4. 过长的参数列表：解决：尽量通过对象进行传参。
5. 全局数据：全局变量会造成一些诡异的 bug；
   解决：封装变量把函数包装起来，控制访问，使能看见修改。再将函数移入一个类，只允许内部代码使用，尽量控制作用域。
6. 可变数据：数据多处引用，更新数据会导致其他地方的应用出现 bug。解决：可以通过封装变量来进行控制修改，查询。
7. 发散式变化：即想修改一个函数，却需要修改不相关度函数。解决：提炼类，进行拆分。
8. 霰弹式修改：一个变化引发多处修改；解决：需要将变化提炼出来；
9. 依恋情结：一个函数跟另外一个模块中的函数或者数据交流密切；解决：提炼函数再函数搬到那个模块中；
10. 数据泥团：相同的数据散落在代码中。解决：将数据放入一个新类，再以对象的形式调用；
11. 基本类型偏执：一些基本类型的变量散落在代码中。解决：将基本类型变成对象。
12. 重复的 swtich：解决：使用堕胎取代条件表达式；
13. 循环语句：解决：以管道操作（filter， map）取代循环。
14. 冗赘的元素：能简单的代码，尽量简单。未来变复杂的时候，再去考虑它。
15. 夸夸其谈的通用性：简单的代码，尽量简单，过早的优化是万恶之源
16. 临时子弹：临时字段指内部某个字段仅为某种特定情况而设。
    临时的字段不应该存在。你需要给他们搬个新家，把所有和临时变量相关的代码搬至那里。
17. 过长的消息链：如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象，这就是消息链；
    解决：消息链意味着客户端会耦合消息链的查找过程。应该将查找过程独立出一个函数
18. 中间人：委托函数过多时，减少委托，移除中间人，让调用者直接访问目标进行操作
19. 内幕交易：减少模块之间的数据交换，并把这种交互放到明面上。
20. 过大的类：当一个类的代码函数太多或者职责太多时，拆掉它。

- 提取新类：当一个大类的部分行为可以分解为一个单独的组件，则可以使用提取类的方式拆分。
- 提取子类：当一个大类的部分行为可以以不同的方式实现或在极少数情况下使用，则可以提取子类进行拆分。

21. 异曲同工的类：即两个类有着相同的功能，但是方法名称不同。解决：重命名方法，去除不必要的重复代码。
22. 纯数据类：纯数据类常常意味着行为被放在错误的地方，处理数据的行为应该从客户端移到纯数据类中。
23. 被拒绝的馈赠：如果子类复用了父类的实现，就应该支持父类的接口。
24. 注释：注释就是告诉你，这个地方该重构了。

## 第五章 介绍重构名录

1. 重构格式的记录

- 名称：重构手法词汇名称
- 速写：找到需要的重构手法
- 动机：明白为什么要做重构，什么情况下不做重构
- 做法：介绍如何一步步做重构
- 范例：以例子说明重构手法如何运作

2. 重构的依据

## 第六章 第一组重构

1. 提炼函数
   反向重构： 内联函数

   ```
   function printOwing(invoice){
       printBanner();
       let outstanding = calculateOutstanding();

       // print details
       console.log(`name: ${invoice.customer}`);
       console.log(`amount: ${outstanding}`);
   }

   // 提炼函数
   function printOwing(invoice){
       printBanner();
       let outstanding = calculateOutstanding();

       // print details
       function printDetails(outstanding){
           console.log(`name: ${invoice.customer}`);
           console.log(`amount: ${outstanding}`);
       }
   }
   ```

- 动机：
  - 一段代码需要花时间去理解。
  - 一个函数一旦超过 6 行。
- 做法
  - 创建新函数，根据函数的意图命名
  - 将提炼的代码从源函数复制到新建的函数
  - 检查是否有变量来自源函数，以参数形式传入
  - 用新函数替换源码中的位置
  - 测试
  - 查看其他代码中是否有相同和相似的代码，有的话进行替换。
- [范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/extractFunction.js)
- ⚠️ 注意：尽量避免直接调用 Date.now() 这样的函数。因为会导致测试行为不可预测。

2. 内联函数
   反向重构： 提炼函数

   ```
    function getRating(driver) {
        return moreThanFiveLateDeliveries(driver) ? 2 : 1;
    }

    function moreThanFiveLateDeliveries(driver) {
        return driver.numberOfLateDeliveries > 5;
    }


    function getRating(driver) {
        return driver.numberOfLateDeliveries > 5 ? 2 : 1;
    }
   ```

- 动机：内容和名称都很清晰时。
- 做法
  - 检查函数，确定不具有多态性。
  - 找出这个函数所有调用点
  - 将这个函数所有调用点替换成函数本体
  - 每次替换之后，执行测试
  - 删除该函数的定义
- [范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/inlineFunction.js)

3. 提炼变量
   反向重构：内联变量

- 动机
  - 表达式复杂且难以阅读
- 做法：
  - 确认提炼的表达式没有副作用
  - 声明不可改变的变量，把想提炼的变量的表达式复制一份，以表达式的结果，赋值给变量
  - 用新变量取代原来的表达式
- [范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/extractVariable.js)

4. 内联变量
   反向重构：提炼变量

- 动机：表达式本身已经能清楚表达信息时
- 做法：
- 检查确认变量赋值语句的右边表达式没有副作用。
- 变量为可修改时，先将其改为不可修改。执行测试，确保该变量只被赋值一次。
- 找到该变量使用的地方，将其替换为表达式，测试
- 重复前面两步，逐一替换。
- 删除该变量的声明和赋值语句， 测试。

5. 改变函数声明

- 动机：发现一些无法准确表达的函数名。
- 做法：
- 简单做法
- 移除参数，确认函数体没有引用该参数
- 修改函数声明，改成你期望的状态
- 找到使用旧函数声明的地方，替换为新函数声明，测试
- 迁移式做法
- 如果有必要的话，先对函数体进行重构，方便后面的提炼步骤。
- 使用提炼函数将函数体提炼成一个新函数。
- 如果函数需要添加参数，使用前面的简单做法即可
- 测试
- 对新函数使用内联函数
- 如果新函数使用了临时名字，再次使用改变函数声明，将其改回原来的名字。
- 测试
- [范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/changeFunctionDeclaration.js)

6.  封装变量

- 动机：数据多处使用，封装监控数据的更新和使用更清晰
- 做法
- 创建封装函数，通过函数访问更新变量
- 执行静态检查
- 逐一更改使用的该变量的代码，每次替换后进行测试
- 限制变量的可见性 -[范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/encapsulateVariable.js)

7.  变量改名

- 动机：好的变量名是整洁编程的核心
- 做法：

  - 多处运用，考虑封装变量
  - 找到该变量使用的地方，逐一修改
  - 测试
  - 范例：

  ```
    // 重构前
    let tpHd = "untitled";
    result += `<h1>${tpHd}</h1>`;
    tpHd = obj["articleTitle"];

    // 重构后
    let _title = "untitled";
    function title(){return _title}
    function setTitle(arg){ _title = arg}
    result += `<h1>${title()}</h1>`;
    setTitle(obj["articleTitle"]);

    // 给常量改名
    // 重构前
    const cpyNm = "Acme Gooseberries";
    // 重构后
    cosnt companyName = "Acme Gooseberries";
    const cpyNm = companyName;
  ```

8.  引入参数对象（参数进行对象化）

- 动机：如果多个数据项总是一起使用时。此时应该封装成对象
- 做法：
- 没有合适的数据结构，就创建一个
- 测试
- 调整所有使用者
- 测试
- 用新数据结构替代之前的参数项
- [范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/introduceParameterObject.js)

9.  函数组成类

- 动机：一组函数操作同一块数据（将这块数据当作参数）的情况，可以组成一个类
- 做法：

  - 对多个函数共用的数据进行封装。
  - 对使用该数据的函数，移入新类。
  - 对处理数据的逻辑提炼函数，移入新类。

- [范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/combineFunctionsIntoClass.js)

10. 函数组合成变换

- 动机：修改一块数据，在原本的数据上增加字段。
- 做法：
  - 创建一个变换函数，创建一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值。
  - 挑选一块逻辑，将其主体移入变换函数中，把结果作为字段添加到输出记录中。修改客户端代码，令其使用这个新字段
- [范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/combineFunctionsIntoTransform.js)

11. 拆分阶段

- 动机：当一段代码处理了两件事情，拆分为单独模块。
- 做法：
- 将第二阶段的代码提炼成独立的函数。
- 测试。
- 引入一个中转数据结构，将其作为参数添加到提炼出的新函数的参数列表中。
- 测试。
- 逐一检查提炼出的“第二阶段函数”的每个参数。如果某个参数被第一阶段用到，就将其移入中转数据结构。每次搬移之后都要执行测试。
- [范例](https://github.com/PLAxiaoxin/refactoring/tree/main/code/src/demo/splitPhase.js)

## 第七章 封装

1. 封装记录
2. 封装集合
3. 以对象代替基本类型
4. 以查询取代临时变量
5. 提炼类
6. 内联类
7. 隐藏委托关系
8. 移除中间人
   9。 替换算法

## 第八章 搬移特性

1. 搬移函数
2. 搬移字段
3. 搬移语句到函数
4. 搬移语句到调用者
5. 以函数调用取代内联代码
6. 移除语句
7. 拆分循环
8. 以管道取代循环
9. 移除死代码

## 第九章 重新组织数据

1. 拆分变量
2. 字段改名
3. 以查询取代派生变量
4. 将引用对象改为值对象
5. 将值对象改为引用对象

## 简化条件逻辑

1. 分解条件表达式
2. 合并条件表达式
3. 以卫语句取代嵌套条件表达式
4. 以多态取代条件表达式
5. 引入特例
6. 引入断言

##
