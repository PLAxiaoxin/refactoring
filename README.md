# refactoring
## 第二章： 重构的原则
### 1. 何谓重构
重构理解：调整软件内部结构，在不改变软件行为的前提，提高代码可理解性。降低修改成本。
- 重构的关键：
1. 使用重构的一系列手法重构，保证代码的可运行，并且能随时停止重构。
2. 重构不改变软件之前的功能。
3. 重构和性能优化相似，但是重构不考虑代码的性能，只让代码更容易理解，性能优化可能会造成代码更难理解。

### 2. 两顶帽子
> 帽子的理解：生活中帽子只会戴一个（比较个性的另说）。比喻添加新功能和重构只能一次进行一个。
### 3. 为何重构
1. 重构改进软件的设计；随着代码的增加和功能增加，出现原先的设计不适合现在的需求，从而导致代码重复，混乱，臃肿，此时代码的设计就需要更改。  
2. 重构使软件共容易理解；代码的理解更容易，更方便后续人员的修改。
3. 重构帮助找到bug；重构时需要更深入的理解代码的表达的意思，从而能找出里面的bug
4. 重构提高编程速度；大型项目业务复杂程度增加，原先的设计不能支撑现有的业务。此时添加新功能，可能会导致之前的代码出现bug。 
### 4. 何时重构
> 重构法则：事不过三，三则重构
1. 预备性重构：让添加新功能（改bug）更容易；在新增功能时，重构之后更容易实现新功能（改bug）此时开始重构。
2. 帮助理解的重构：使代码更易动；修改一些变量的名字，让代码更易懂。
3. 捡垃圾式重构：在开发功能时，发现可以重构的代码。但是不想从现在的任务停下，此时记录需要重构的地方。完成任务再回来重构。一点点修改。
4. 有计划的重构和见机行事的重构；计划重构就是给出具体的时间进行重构，见机行事的重构就是在项目开发过程中，发现可以重构但是不耗时的重构。
5. 长期重构；指在开发过程中团队改到，需要重构的代码，就进行重构。保证是一个长期的行为。
6. 复审代码时重构(code review);代码审核时进行重构。重构时代码的开发者和审核者都在现场。这个也是导向到结对编程：在进行的过程中，进行代码重构
7. 重构的禁忌；就是什么时候不该进行重构。一代码凌乱但是不需要修改时。二重写比重构还容易时。
### 5. 重构的挑战
1. 延缓新功能开发
    Q：重构会延缓新功能的开发的看法是普遍的的看法，如何处理？
    A:1）新功能非常小，重构很大。应该先进行功能的开发。
      2）重构能让新功能更好的开发，优先重构，再开发新功能。
      3）需要重构的代码开发中没有带来额外的问题，不去重构
      4）重构的代码没有想到优化的点，那就延迟重构

2. 代码所有权
    Q: 代码所有权对重构的影响？
    A：例如：调用者是另外一个团队，而我没有权限写入他们的代码库，甚至不知道谁调用了这些方法。代码所有权的会妨碍重构。虽然可以保留之前的函数声明，但是会让代码变的复杂。所以不建议搞细粒度的代码所有制。宽松的代码所有制，方便跨团队合作。
3. 分支
   Q：分支对重构的影响？
   A：团队开发时，都是基于主分支新建分支开发，当A在重构，而B在开发功能，如果B的功能依赖A重构的方法。B的功能代码合并到主分支，就会引起冲突。
     1）使用持续集成（CI），至少保证每天都向主分支集成一次。
     2）将大功能拆分为小块，将无法拆小的功能呢隐藏
4. 测试
   Q：测试对重构有什么影响？
   A：测试可以保证添加的新功能、重构更安全，能更迅速的找出bug，

5. 遗留代码
   Q: 遗留代码对重构的影响？
   A：遗留代码的重构，那么就必须添加测试，测试可以保证重构的安全，以及理顺遗留的代码。
6. 数据库
   Q：数据库的重构经常出问题，如何处理？
   A：重构时要小步修改，修改必须完整。重构后分多次发布来完成。有问题可以方便回滚。


### 6. 重构、架构和YAGUI（你不会需要架构）
  1. 重构可以改变架构固定导致的问题。
  2. 重构可以设计出良好的代码库
  3. 在软件加入灵活性机制
  4. 使用简单设计、增量式设置或者YAGUI
### 7. 重构与软件的开发过程
  1. 重构的基础时自测试代码，避免编程的bug。
  2. 重构的过程中不应该影响其他的开发。
  3. 重构过程中应该持续集成
### 8. 重构与性能
  - 快速开发的高性能呢软件的三个方法
  1. 时间预算法：给每个模块分配好时间和占有空间。
  2. 持续关注法：开发者在任何时间做任何的事情，都要保持系统的高性能，但是通常会使程序难以维护，减缓开发速度。
  3. 性能提升法：当性能问题出现时，去解决出现的问题，从而提高性能。如果重构没有让性能提升，那就撤销修改，直到性能优化成功。
### 9. 重构起源何处
  认识到重构对提高生产力非常重要的是：Ward Cunningham 和 Kent Beak（沃德・坎宁安 和 肯特・比克）
### 10. 自动化重构
  Q：何谓自动化重构？
  A：IDE 通过 语法树来分析和重构程序代码的方式。通过识别相同代码来自动化重构。

## 第三章：代码的坏味道
1. 神秘命名：即函数，变量，类和模块的命名无法表达正确的意思。解决：使用正确可以表达意思的变量名
2. 重复代码
> 三种类型：
 - 位于同一个类：提炼成新方法进行调用
 - 位于不同子类：提炼成方法到父类。
 - 位于完全不相干的类：提炼成一个新类，将重复代码放入新类中。
3. 过长的函数：函数过长导致理解困难。解决：当你感觉需要用注释来说明的时候，就可以把这段代码提到独立函数。
4. 过长的参数列表：解决：尽量通过对象进行传参。
5. 全局数据：全局变量会造成一些诡异的bug；
    解决：封装变量把函数包装起来，控制访问，使能看见修改。再将函数移入一个类，只允许内部代码使用，尽量控制作用域。
6. 可变数据：数据多处引用，更新数据会导致其他地方的应用出现bug。解决：可以通过封装变量来进行控制修改，查询。
7. 发散式变化：即想修改一个函数，却需要修改不相关度函数。解决：提炼类，进行拆分。
8. 霰弹式修改：一个变化引发多处修改；解决：需要将变化提炼出来；
9. 依恋情结：一个函数跟另外一个模块中的函数或者数据交流密切；解决：提炼函数再函数搬到那个模块中；
10. 数据泥团：相同的数据散落在代码中。解决：将数据放入一个新类，再以对象的形式调用；
11. 基本类型偏执：一些基本类型的变量散落在代码中。解决：将基本类型变成对象。
12. 重复的swtich：解决：使用堕胎取代条件表达式；
13. 循环语句：解决：以管道操作（filter， map）取代循环。
14. 冗赘的元素：能简单的代码，尽量简单。未来变复杂的时候，再去考虑它。
15. 夸夸其谈的通用性：简单的代码，尽量简单，过早的优化是万恶之源
16. 临时子弹：临时字段指内部某个字段仅为某种特定情况而设。
    临时的字段不应该存在。你需要给他们搬个新家，把所有和临时变量相关的代码搬至那里。
17. 过长的消息链：如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象，这就是消息链；
    解决：消息链意味着客户端会耦合消息链的查找过程。应该将查找过程独立出一个函数
18. 中间人：委托函数过多时，减少委托，移除中间人，让调用者直接访问目标进行操作
19. 内幕交易：减少模块之间的数据交换，并把这种交互放到明面上。
20. 过大的类：当一个类的代码函数太多或者职责太多时，拆掉它。
  两种拆分方法：
  1. 提取新类：当一个大类的部分行为可以分解为一个单独的组件，则可以使用提取类的方式拆分。
  2. 提取子类：当一个大类的部分行为可以以不同的方式实现或在极少数情况下使用，则可以提取子类进行拆分。
21. 异曲同工的类：即两个类有着相同的功能，但是方法名称不同。解决：重命名方法，去除不必要的重复代码。
22. 纯数据类：纯数据类常常意味着行为被放在错误的地方，处理数据的行为应该从客户端移到纯数据类中。
23. 被拒绝的馈赠：如果子类复用了父类的实现，就应该支持父类的接口。
24. 注释：注释就是告诉你，这个地方该重构了。

## 第五章 介绍重构名录
- 1. 重构格式的记录
  - 名称：重构手法词汇名称
  - 速写：找到需要的重构手法
  - 动机：明白为什么要做重构，什么情况下不做重构
  - 做法：介绍如何一步步做重构
  - 范例：以例子说明重构手法如何运作
- 2. 重构的依据

## 第六章 第一组重构
1. 提炼函数
    ```
    function printOwing(invoice){
        printBanner();
        let outstanding = calculateOutstanding();

        // print details
        console.log(`name: ${invoice.customer}`);
        console.log(`amount: ${outstanding}`);
    }

    // 提炼函数
    function printOwing(invoice){
        printBanner();
        let outstanding = calculateOutstanding();

        // print details
        function printDetails(outstanding){
            console.log(`name: ${invoice.customer}`);
            console.log(`amount: ${outstanding}`);
        }
    }
    ```
    - 动机
2. 内联函数
